//***************************************************************
// 			1 канальный Вольтмер на LED							*
//***************************************************************

//Программа одноканального вольтметра с 3-х разрядным светодиодным
//индикатором с общим КАТОДОМ и динамической индикацией

//Предусмотрена возможность произвольного чередования линий вывода
//светодиодного индикатора, что позволяет применять разные типы CPU
//и индикаторов и упрощает разводку печатной платы

//CPU Atmega8
//Внутренний RC осциллятор 2МГц
//Фьюзы CKSEL=0010, SUT=10
//Компилятор WinAVR20090313
//Размер кода байт 1096


#define F_CPU 2000000L // частота процессора

// -------------- Библиотеки ----------------------------------
#include <avr/io.h>			// библиотека ввода вывода
#include <avr/pgmspace.h>	// библиотека для работы с flash
#include <util/delay.h>		// библиотека задержек
#include <avr/wdt.h>		// библиотека сторожевого таймера
#include <avr/interrupt.h>	// библиотека прерываний

// -------------- Подключение LED -----------------------------
#define maskb 0b11111111 // задействованные биты порта В/В
#define B PB0 // сегменты LED по пинам порта В/В
#define G PB1
#define C PB2
#define H PB3
#define D PB4
#define E PB5
#define A PB6
#define F PB7


// -------------- Определения ----------------------------------
#define rb(x) (pgm_read_byte(&x))	// макрос чтения байта из flash

#define PORT_SEG PORTB	// порт сегментов
#define DDR_SEG DDRB	// регистр направления ввода/вывода

#define PORT_LED PORTD	// порт выбора LED индикатора
#define DDR_LED DDRD	// регистр направления ввода/вывода

#define LED0 0	// индикатор младшего разряда
#define LED1 1	// индикатор среднего разряда
#define LED2 2	// индикатор старшего разряда


// ------------ Переменные и константы -------------------------
// Коды цифр от 0 до 9 и "пробела" для LED с общим АНОДОМ
// сегмент a -> бит0, сегмент h -> бит7  (бит=1 сегмент погашен, бит=0 сегмент горит)
//const unsigned char code_sym[11] PROGMEM={0xC0,0xF9,0xA4,0xB0,0x99,
//										  0x92,0x82,0xF8,0x80,0x90,0xFF};

// коды цифр для LED с общим катодом
const unsigned char code_sym[11] PROGMEM={0x3F,0x06,0x5B,0x4F,0x66,
										  0x6D,0x7D,0x07,0x7F,0x6F,0x00};


const int Um=5000; 	// максимальное напряжение умноженное на 100
long int NV;		// код напряжения
unsigned char Dig[3];	// массив цифр напряжения по разрядам
volatile unsigned int t;		// счетчик дискретов времени
volatile unsigned char pos,point;	// номер позиции индикатора и флаг десятичной точки



// Список функций
int mesuare_U(void); void mem_value(void);
void LED_OFF(void); void LED_ON(unsigned char code);


// -------------- Вектор прерываний ----------------------------
ISR (BADISR_vect)	// Заглушка для неиспользуемых прерываний
{
reti();
}

// -------------------------------------------------------------
ISR (TIMER0_OVF_vect)	// Динамическая индикация по переполнению таймера0
{ unsigned char numer;

    TCNT0=190;	// уменьшаем период срабатывания до 2мс

	// Гасим все индикаторы и их сегменты
	LED_OFF();
	_delay_us(400);	// пауза, регулирующая яркость

	if (pos==1) {point=0;}	// Установка флага десятичной точки
	else {point=1;}

	// Вывод очередной цифры
	switch (pos) // Включаем соответствующий разряд
	{ case 0: {PORT_LED&=~(1<<LED0);} break;
	  case 1: {PORT_LED&=~(1<<LED1);} break;
	  case 2: {PORT_LED&=~(1<<LED2);} break;
	}

	numer=Dig[pos];// Считываем запомненный вес текущего разряда
	LED_ON(rb(code_sym[numer]));


	if (pos==2) {pos=0;} // смена позиции
		else {pos++;}
	t++;	// счетчик времени


}


//**************** Начало программы ****************************
int main(void)
{
unsigned char i;// счетчик замеров
unsigned int NA;// код АЦП


ACSR=0x80;	// выкл компаратора

// Настройка АЦП
ADMUX=0xC2;	// канал АЦП2, внутренний ИОН 2,56В с конденсатором
ADCSR=0x84;	// вкл АЦП, Кд=16 (125кГц), правое выравнивание бит


// Настройка портов
DDR_SEG=maskb;	//линии сегментов на вывод
DDR_LED=( (1<<LED2)|(1<<LED1)|(1<<LED0) );	//линии индикаторов на вывод

PORT_SEG&=~maskb;	// откл индикаторов
PORT_LED&=~( (1<<LED2)|(1<<LED1)|(1<<LED0) );


// Включение сторожевого таймера
cli();
wdt_enable(WDTO_2S);

// Настройка Таймера0
TCCR0=0x03;	// Кд=64, Тпер=8,192мс
TIMSK=0x01;	// разрешить прерывания по переполнению Таймера0
sei();

// Начальные присвоения
t=0; pos=0;

// ************ Основной цикл **********************************
while(1)
 {
 asm("wdr");	// сброс сторожевого таймера


// ~~~~~~~~ ЗАМЕР АЦП ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	ADMUX=0xC2;	// вкл 1-ый канал
	// суммируем 16 замеров АЦП
	NA=0;
	for (i=0;i<16;i++)	{NA+=mesuare_U();}
	NA/=16;	// вычисляем средний код

	// масштабируем код АЦП в код напряжения
	NV=(long int) NA*Um;
	NV>>=10; // делим на 1024

	// запись кода напряжения
	mem_value();

	asm("wdr");

// ~~~~~~~~ ПАУЗА 0,5с ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	t=0;
	while(t<250);

 }
return 0;
}


// ******** Функции ********************************************
// Замер кода АЦП
int mesuare_U(void)
{
	ADCSR|=(1<<ADSC);	// пуск замера
	while (bit_is_set(ADCSR,ADSC)); // крутимся в цикле до конца замера
	return (ADCL+(ADCH<<8));
}

//----------------------------------------------------------------
// Запись кода напряжения
void mem_value(void)
{ unsigned char R;	// остаток при округлении
	R=NV%10;
	NV-=R;
	if (R>5) {NV+=10;}	// округлим младший разряд

	// расчет и индикация младшего разряда
	NV/=10;
	R=(NV%10);
	NV-=R;
	Dig[0]=R;

	// расчет и индикация среднего разряда
	NV/=10;
	R=(NV%10);
	NV-=R;
	Dig[1]=R;

	// расчет и индикация старшего разряда
	NV/=10;
	if (NV==0) {Dig[2]=10;} // гашение нуля в старшем разряде
	else {Dig[2]=NV;}
}


//-----------------------------------------------------------------
void LED_OFF(void) // Гашение индикаторов и их сегментов
{
//PORT_LED&=~( (1<<LED0)|(1<<LED1)|(1<<LED2) ); // Гасим разряды
//PORT_SEG|=maskb; // А на сегменты мы подаем напряжение обратной полярности
				 // чтобы быстрее рассосать накопленный заряд светодиодов
				 // и улучшить контраст изображения
PORT_LED|=( (1<<LED0)|(1<<LED1)|(1<<LED2) );
PORT_SEG=0b00000000;

}

//-----------------------------------------------------------------
void LED_ON(unsigned char code) // Включение и выключение сегментов согласно коду
{
if (code&(1<<0)) {PORT_SEG|=(1<<A);}
	else {PORT_SEG&=~(1<<A);}
if (code&(1<<1)) {PORT_SEG|=(1<<B);}
	else {PORT_SEG&=~(1<<B);}
if (code&(1<<2)) {PORT_SEG|=(1<<C);}
	else {PORT_SEG&=~(1<<C);}
if (code&(1<<3)) {PORT_SEG|=(1<<D);}
	else {PORT_SEG&=~(1<<D);}
if (code&(1<<4)) {PORT_SEG|=(1<<E);}
	else {PORT_SEG&=~(1<<E);}
if (code&(1<<5)) {PORT_SEG|=(1<<F);}
	else {PORT_SEG&=~(1<<F);}
if (code&(1<<6)) {PORT_SEG|=(1<<G);}
	else {PORT_SEG&=~(1<<G);}

if (point==1) {PORT_SEG&=~(1<<H);}	// включение десятичной точки
else {PORT_SEG|=(1<<H);} // выключение десятичной точки
}
